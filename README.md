# Transactions processor

## Description

This is an implementation of a simple payment engine that reads a series of transactions from CSV, updates the client accounts, handles the disputes and chargeback, and outputs the state of clients' accounts as a CSV.

There is an assumption the transaction is a `u32` value.

## Entrypoint components

```mermaid

graph TD
A[get_input_file] --> B[crossbeam::channel::bounded]
B --> C[processors::marshaller]
C --> D[processors::process_transactions]
D --> E[processors::forwarder_to_stdout]
E --> F[std::thread::join]

```

## How to run

```sh
cargo run -- tests/input.csv > output.csv
```

## Testing

Most of the edge cases are covered by unit tests in the `Payments` module

```sh
cargo test
```

## Assumptions

### Client ID

| Decision | Motivation |
|----------| -----------|
| The transaction generated by `client_id` "A" cannot be altered (Disputed etc..) by the client with id "B" | Transaction are attached to one account |

### Performance

| Decision | Motivation |
|----------| -----------|
| Marshaling and account processing are separated and put into different threads.| performance optimisation which could be useful in case of large volume of data|

### Extensibility

| Decision | Motivation |
|----------| -----------|
|The input (`io:Read`) is exposed to the root | we may want to attach the different data source |
|The output (`Sender<ClientID, Client)>`) is exposed to the root | we may want to use a different destination for data|
